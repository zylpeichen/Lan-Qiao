/*
题目描述

某机构举办球票大奖赛。获奖选手有机会赢得若干张球票。

主持人拿出 N 张卡片（上面写着 1-N 的数字），打乱顺序，排成一个圆圈。

你可以从任意一张卡片开始顺时针数数: 1,2,3 

如果数到的数字刚好和卡片上的数字相同，则把该卡片收入囊中，从下一个卡片重新数数。

直到再无法收获任何卡片，游戏结束。囊中卡片数字的和就是赢得球票的张数。

比如：

卡片排列是：1 2 3

我们从 1 号卡开始数，就把 1 号卡拿走。再从 2 号卡开始，但数的数字无法与卡片对上，很快数字越来越大，不可能再拿走卡片了。因此这次我们只赢得了 1 张球票。

还不算太坏！如果我们开始就傻傻地从 2 或 3 号卡片数起，那就一张卡片都拿不到了。

如果运气好，卡片排列是 2 1 3，那我们可以顺利拿到所有的卡片！

本题的目标：已知顺时针卡片序列，随便你从哪里开始数，求最多能赢多少张球票（就是收入囊中的卡片数字之和）
输入描述

第一行一个整数 N (N≤100)，表示卡片数目。

第二行 N 个整数，表示顺时针排列的卡片。
输出描述

输出一行，一个整数，表示最好情况下能赢得多少张球票。

输入输出样例
示例
    输入

3
1 2 3

    输出

1
*/


#include <bits/stdc++.h>
using namespace std;
const int N = 1e2 + 10;
int n;
int a[N],backup[N];  // 定义两个数组，backup 数组为备份数组，因为 a 数组会变 

int get(int k) // 该函数用来返回从不同的地方最终获得的球票数 
{
	int sum = 0, cnt = 1;  // 定义 sum 为最终的球票数，cnt 为 
	memcpy(a, backup, sizeof backup);  // 将 backup 复制给 a 数组 
	// for (int i = 0; i < n; i++)
	// a[i] = backup[i]; 
	while (true)
	{
		while (a[k] == 0) // 如果当前的 a 数组为 0，则匹配下一个 
			k = (k + 1) % n;
			if (a[k] == cnt) { // 如果当前的卡片数组和我们按照顺序的 cnt 一样，则加到 sum 
				sum += a[k];
				a[k] = 0;  // 让已经拿出去的卡片的位置置 0 
				cnt = 1;	// 重新在初始化 cnt ，使取出后下一个是以 1 开始 
			}	
		else cnt ++;  // 如果当前的卡片数组和我们的 cnt 不一样，则 cnt++ 
		k = (k + 1) % n;  // 不管我们有没有取到卡片，我们都是要往后走的 
		if (*max_element(a, a + n) == 0)   //如果整个数组的最大值是 0，则说明取完了 ，返回 
		return sum;
		if (cnt > n) return sum;    // 如果 cnt 大于 n，就说明再也不可能取到卡片了，直接返回 
	}
	return -1;
}
int main ()
{
	cin >> n;  // 定义 卡片数 
	for (int i = 0; i < n; i++)
		cin >> backup[i];   // 输入数 放置在数组 backup 中 
	int res = 0;
	for (int i = 0; i < n; i++)	// i 表示从不同地方开始 
		res = max(res,get(i));	// 对比每次不同地方的结果进行比较，选最大的 
	cout << res;
	return 0;
}

